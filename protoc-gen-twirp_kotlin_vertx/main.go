// Copyright 2018 Twitch Interactive, Inc.  All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License"). You may not
// use this file except in compliance with the License. A copy of the License is
// located at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// or in the "license" file accompanying this file. This file is distributed on
// an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
// express or implied. See the License for the specific language governing
// permissions and limitations under the License.

package main

import (
	"bytes"
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"unicode"

	"github.com/golang/protobuf/proto"
	"github.com/golang/protobuf/protoc-gen-go/descriptor"
	plugin "github.com/golang/protobuf/protoc-gen-go/plugin"
	"github.com/twitchtv/twirp/internal/gen"
	"github.com/twitchtv/twirp/internal/gen/stringutils"
	"github.com/twitchtv/twirp/internal/gen/typemap"
)

func main() {
	versionFlag := flag.Bool("version", false, "print version and exit")
	flag.Parse()
	if *versionFlag {
		fmt.Println(gen.Version)
		os.Exit(0)
	}

	g := newGenerator()
	gen.Main(g)
}

func newGenerator() *generator {
	return &generator{output: new(bytes.Buffer)}
}

type generator struct {
	reg    *typemap.Registry
	output *bytes.Buffer
}

func (g *generator) Generate(in *plugin.CodeGeneratorRequest) *plugin.CodeGeneratorResponse {
	genFiles := gen.FilesToGenerate(in)
	g.reg = typemap.New(in.ProtoFile)

	resp := new(plugin.CodeGeneratorResponse)
	for _, f := range genFiles {
		respFile := g.generateFile(in, f)
		if respFile != nil {
			resp.File = append(resp.File, respFile)
		}
	}

	return resp
}

func (g *generator) generateFile(in *plugin.CodeGeneratorRequest, file *descriptor.FileDescriptorProto) *plugin.CodeGeneratorResponse_File {
	useCoroutine := strings.Contains(in.GetParameter(), "use_coroutine")

	g.P("// Code generated by protoc-gen-twirp_kotlin_vertx ", gen.Version, ", DO NOT EDIT.")
	g.P("// source: ", file.GetName())
	g.P()

	g.P("package ", getJavaPackage(file))
	g.P()
	g.P(`import com.google.protobuf.Message`)
	g.P(`import com.google.protobuf.Parser`)
	g.P(`import io.netty.buffer.ByteBufInputStream`)
	g.P(`import io.vertx.core.Future`)
	g.P(`import io.vertx.core.buffer.Buffer`)
	g.P(`import io.vertx.ext.web.Router`)
	g.P(`import io.vertx.ext.web.RoutingContext`)
	if useCoroutine {
		g.P(`import kotlinx.coroutines.CoroutineScope`)
		g.P(`import kotlinx.coroutines.launch`)
	}

	for _, service := range file.Service {
		g.generateProtobufClient(in, file, service, useCoroutine)
	}

	resp := new(plugin.CodeGeneratorResponse_File)
	resp.Name = proto.String(ktFileName(file))
	resp.Content = proto.String(g.output.String())
	g.output.Reset()

	return resp
}

func (g *generator) generateProtobufClient(in *plugin.CodeGeneratorRequest, file *descriptor.FileDescriptorProto, service *descriptor.ServiceDescriptorProto, useCoroutine bool) {
	g.P()
	comments, err := g.reg.ServiceComments(file, service)
	if err == nil && comments.Leading != "" {
		g.P(`/**`)
		g.printComments(comments, ` * `)
		g.P(` */`)
	}
	g.P(`interface `, serviceName(service), `Service {`)

	for _, method := range service.Method {
		g.P()
		comments, err := g.reg.MethodComments(file, service, method)
		if err == nil && comments.Leading != "" {
			g.P(`    /**`)
			g.printComments(comments, `     * `)
			g.P(`     */`)
		}

		methName := methodName(method)
		inputName := methodInputName(method)

		inputType := getJavaType(in, method.GetInputType())
		outputType := getJavaType(in, method.GetOutputType())

		if useCoroutine {
			g.P(`    suspend fun `, methName, `(routingContext: RoutingContext, `, inputName, `: `, inputType, `): `, outputType)
		} else {
			g.P(`    fun `, methName, `(routingContext: RoutingContext, `, inputName, `: `, inputType, `): Future<`, outputType, `>`)
		}
	}

	g.P()
	g.P(`    fun addRoutes(router: Router, coroutineScope: CoroutineScope, prefix: String = "/twirp") {`)
	g.P(`        val serviceName = `, strconv.Quote(fullServiceName(file, service)))
	g.P(`        val base = "$prefix/$serviceName/"`)
	g.P()
	for _, method := range service.Method {
		methName := methodName(method)
		inputType := getJavaType(in, method.GetInputType())
		if useCoroutine {
			g.P(`        router.twirp(coroutineScope, base + "`, method.GetName(), `", `, inputType, `.parser(), ::`, methName, `)`)
		} else {
			g.P(`        router.twirp(base + "`, method.GetName(), `", `, inputType, `.parser(), ::`, methName, `)`)
		}
	}
	g.P(`    }`)
	g.P()

	if useCoroutine {
		g.P(`    fun <Request : Message, Response : Message> Router.twirp(`)
		g.P(`        coroutineScope: CoroutineScope,`)
		g.P(`        path: String,`)
		g.P(`        parser: Parser<Request>,`)
		g.P(`        handler: suspend (RoutingContext, Request) -> Response`)
		g.P(`    ) = post(path).handler { ctx ->`)
		g.P(`        coroutineScope.launch {`)
		g.P(`            kotlin.runCatching {`)
		g.P(`                val request = parser.parseFrom(ByteBufInputStream(ctx.body.byteBuf))`)
		g.P(`                handler(ctx, request)`)
		g.P(`            }.onSuccess { response ->`)
		g.P(`                ctx.end(Buffer.buffer(response.toByteArray()))`)
		g.P(`            }.onFailure {`)
		g.P(`                ctx.fail(500, it)`)
		g.P(`            }`)
		g.P(`        }`)
		g.P(`    }`)
		} else {
		g.P(`    fun <Request : Message, Response : Message> Router.twirp(`)
		g.P(`        path: String,`)
		g.P(`        parser: Parser<Request>,`)
		g.P(`        f: (RoutingContext, Request) -> Future<Response>`)
		g.P(`    ) = post(path).handler { ctx ->`)
		g.P(`        kotlin.runCatching {`)
		g.P(`            val request = parser.parseFrom(ByteBufInputStream(ctx.body.byteBuf))`)
		g.P(`            f(ctx, request)`)
		g.P(`        }.onSuccess { response ->`)
		g.P(`            response.onSuccess {`)
		g.P(`                ctx.end(Buffer.buffer(it.toByteArray()))`)
		g.P(`            }.onFailure {`)
		g.P(`                ctx.fail(500, it)`)
		g.P(`            }`)
		g.P(`        }.onFailure { throwable ->`)
		g.P(`            ctx.fail(500, throwable)`)
		g.P(`        }`)
		g.P(`    }`)
	}

	g.P(`}`)
}

func (g *generator) P(args ...string) {
	for _, v := range args {
		g.output.WriteString(v)
	}
	g.output.WriteByte('\n')
}

func (g *generator) printComments(comments typemap.DefinitionComments, prefix string) {
	text := strings.TrimSuffix(comments.Leading, "\n")
	for _, line := range strings.Split(text, "\n") {
		g.P(prefix, strings.TrimPrefix(line, " "))
	}
}

func serviceName(service *descriptor.ServiceDescriptorProto) string {
	return stringutils.CamelCase(service.GetName())
}

func clientName(service *descriptor.ServiceDescriptorProto) string {
	return serviceName(service) + "Client"
}

func fullServiceName(file *descriptor.FileDescriptorProto, service *descriptor.ServiceDescriptorProto) string {
	name := serviceName(service)
	if pkg := file.GetPackage(); pkg != "" {
		name = pkg + "." + name
	}
	return name
}

func methodName(method *descriptor.MethodDescriptorProto) string {
	return lowerCamelCase(method.GetName())
}

func methodInputName(meth *descriptor.MethodDescriptorProto) string {
	fullName := meth.GetInputType()
	split := strings.Split(fullName, ".")
	return lowerCamelCase(split[len(split)-1])
}

func ktFileName(f *descriptor.FileDescriptorProto) string {
	name := stringutils.BaseName(f.GetName())
	name = stringutils.CamelCase(name) + ".kt"
	return strings.Replace(getJavaPackage(f), ".", "/", -1) + "/" + name
}

func getJavaPackage(file *descriptor.FileDescriptorProto) string {
	pkg := file.Options.GetJavaPackage()
	if pkg != "" {
		return pkg
	}
	return file.GetPackage()
}

func findProtoFile(in *plugin.CodeGeneratorRequest, messageName string) *descriptor.FileDescriptorProto {
	for _, v := range in.GetProtoFile() {
		pkg := v.GetPackage()
		for _, r := range v.GetMessageType() {
			if "."+pkg+"."+r.GetName() == messageName {
				return v
			}
		}
	}
	return nil
}

func getJavaType(in *plugin.CodeGeneratorRequest, name string) string {
	file := findProtoFile(in, name)

	pkg := getJavaPackage(file)
	multi := file.Options.GetJavaMultipleFiles()

	p := strings.LastIndex(name, ".")
	typeName := name[p+1:]

	if pkg == "" {
		return fmt.Sprintf("%s", typeName)
	} else if multi {
		return fmt.Sprintf("%s.%s", pkg, typeName)
	} else {
		outerClass := getJavaOuterClassName(file)
		return fmt.Sprintf("%s.%s.%s", pkg, outerClass, typeName)
	}
}

func getProtoName(file *descriptor.FileDescriptorProto) string {
	name := file.GetName()
	ext := filepath.Ext(name)
	if ext == ".proto" || ext == ".protodevel" {
		name = name[0 : len(name)-len(ext)]
	}
	return name
}

func getJavaOuterClassName(file *descriptor.FileDescriptorProto) string {
	name := file.Options.GetJavaOuterClassname()
	if name != "" {
		return name
	}

	name = stringutils.CamelCase(stringutils.BaseName(getProtoName(file)))
	outer := name + "OuterClass"
	for _, desc := range file.GetMessageType() {
		if strings.Title(desc.GetName()) == name {
			return outer
		}
	}

	for _, desc := range file.GetService() {
		if strings.Title(desc.GetName()) == name {
			return outer
		}
	}

	for _, desc := range file.GetEnumType() {
		if strings.Title(desc.GetName()) == name {
			return outer
		}
	}

	return name
}

func lowerCamelCase(s string) string {
	name := stringutils.CamelCase(s)
	runes := []rune(name)
	runes[0] = unicode.ToLower(runes[0])
	return string(runes)
}
